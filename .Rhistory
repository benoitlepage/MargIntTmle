int.terms[[index]] <- paste0(A1nodes[i]," * ",Vnodes[j])
index <- index + 1
}
}
working.msm <- paste0("Y ~")
model.msm <- paste0(Ynodes, " ~")
for(i in 1:length(int.terms)) {
working.msm <- paste0(working.msm," + ",int.terms[[i]])
model.msm <- paste0(model.msm," + ",int.terms[[i]])
}
rm(index,i,j,int.terms)
# summary.measures = valeurs des coefficients du MSM associés à chaque régime
# array: num.regimes x num.summary.measures x num.final.Ynodes -
# measures summarizing the regimes that will be used on the right hand side of working.msm
# (baseline covariates may also be used in the right hand side of working.msm and do not need to be included in summary.measures)
summary.measures.reg <- array(0, dim = c(length(A1nodes) + 1,
length(A1nodes),
length(Ynodes)))
for(i in 1:length(A1nodes)) {
summary.measures.reg[1 + i,i,] <- 1
}
colnames(summary.measures.reg) <- A1nodes
# regime=
# binary array: n x numAnodes x numRegimes of counterfactual treatment or a list of 'rule' functions
# colnames(regime) should be the same as Anodes (in the same order)
regimes.MSM <- array(NA, dim = c(nrow(data), numAnodes, nb.regimes))
for(i in 1:nb.regimes) {
for(r in 1:nrow(data)) {
regimes.MSM[r,,i] <- summary.measures.reg[i,1:numAnodes,1]
}
}
colnames(regimes.MSM) <- A1nodes
}
# A1node.matrix <- matrix(0, nrow = (length(A1nodes) + 1), ncol = length(A1nodes))
# for(i in 1:ncol(A1node.matrix)) {
#   A1node.matrix[i+1,i] <- 1
# }
# colnames(A1node.matrix) <- A1nodes
# A2node.matrix <- matrix(0, nrow = (length(A2nodes) + 1), ncol = length(A2nodes))
# for(i in 1:ncol(A2node.matrix)) {
#   A2node.matrix[i+1,i] <- 1
# }
# colnames(A2node.matrix) <- A2nodes
#
#
#
# Anode.matrix <- matrix(NA, nrow = 0, #nrow = nrow(A1node.matrix) * nrow(A2node.matrix),
#                        ncol = length(A1nodes) * length(A2nodes))
# for(i in 1:nrow(A1node.matrix)) {
#   for(j in 1:nrow(A2node.matrix)) {
#     Anode.matrix <- rbind(Anode.matrix,
#                           c(A1node.matrix[i,],A2node.matrix[j,]))
#   }
# }
# for(i in 1:length(A1nodes)) {
#   for(j in (length(A1nodes) +1):(length(A1nodes) + length(A2nodes))) {
#     Anode.matrix <- cbind(Anode.matrix,
#                           as.data.frame(Anode.matrix)[,i] * as.data.frame(Anode.matrix)[,j])
#   }
# }
if(gcomp == TRUE) {
# test length SL.library$Q
SL.library$Q <- ifelse(length(SL.library$Q) > 1, "glm", SL.library$Q) # +++++ DELETE +++++++++++ ?????
# simplify SL.library$g because g functions are useless with g-computation
SL.library$g <- "SL.mean"
iptw.only <- FALSE
}
ltmle_MSM <- ltmle::ltmleMSM(data = data,
Anodes = Anodes,
Cnodes = Cnodes,
Lnodes = c(interm.Lnodes),
Ynodes = Ynodes,
survivalOutcome = survivalOutcome,
Qform = Qform,
gform = gform,
gbounds = gbounds,
Yrange = Yrange,
deterministic.g.function = deterministic.g.function,
SL.library = SL.library,
SL.cvControl = SL.cvControl,
regimes = regimes.MSM, # instead of abar
working.msm= working.msm,
summary.measures = summary.measures.reg,
final.Ynodes = final.Ynodes,
stratify = stratify,
msm.weights = msm.weights,
estimate.time = estimate.time,
gcomp = gcomp,
iptw.only = iptw.only,
deterministic.Q.function = deterministic.Q.function,
variance.method = variance.method,
observation.weights = observation.weights,
id = id)
bootstrap.res <- NULL
if(gcomp == TRUE) {
# bootstrap.res <- data.frame("beta.Intercept" = rep(NA, B),
#                             "beta.A1" = rep(NA, B),
#                             "beta.A2" = rep(NA, B),
#                             "beta.A1A2" = rep(NA, B))
bootstrap.res.list <- list()
if (is.null(boot.seed)) {
print("boot.seed argument is null, please add a seed in the int.ltmleMSM function")}
set.seed <- boot.seed
for (b in 1:B){
# sample the indices 1 to n with replacement
bootIndices <- sample(1:nrow(data), replace=T)
bootData <- data[bootIndices,]
if ( round(b/100, 0) == b/100 ) print(paste0("bootstrap number ",b))
suppressMessages(boot_ltmle_MSM <- ltmle::ltmleMSM(data = bootData,
Anodes = Anodes,
Lnodes = c(interm.Lnodes),
Ynodes = Ynodes,
survivalOutcome = survivalOutcome,
Qform = Qform,
gform = gform,
gbounds = gbounds,
Yrange = Yrange,
deterministic.g.function = deterministic.g.function,
SL.library = SL.library,
SL.cvControl = SL.cvControl,
regimes = regimes.MSM, # instead of abar
working.msm= working.msm,
summary.measures = summary.measures.reg,
final.Ynodes = final.Ynodes,
stratify = stratify,
msm.weights = msm.weights,
estimate.time = FALSE,
gcomp = gcomp,
iptw.only = iptw.only,
deterministic.Q.function = deterministic.Q.function,
variance.method = variance.method,
observation.weights = observation.weights,
id = id))
bootstrap.res.list[[b]] <- boot_ltmle_MSM$beta
}
bootstrap.res <- matrix(NA, nrow = B, ncol = length(bootstrap.res.list[[1]]))
for(b in 1:B) {
for(i in 1:length(bootstrap.res.list[[1]])) {
bootstrap.res[b,i] <- bootstrap.res.list[[b]][i]
}
}
colnames(bootstrap.res) <- names(boot_ltmle_MSM$beta)
bootstrap.res <- data.frame(bootstrap.res)
}
return(list(ltmle_MSM = ltmle_MSM,
working.msm = working.msm,
data = data,
A1nodes = A1nodes,
A2nodes = A2nodes,
Vnodes = Vnodes,
Ynodes = Ynodes,
bootstrap.res = bootstrap.res))
}
# ---------------------------------------------------------------------------- #
### interaction entre 2 expositions à 3 classes ----
# ---------------------------------------------------------------------------- #
## Example 1
set.seed(12345)
df <- generate.data.multcat(N = 1000, b = param.causal.model.multcat())
head(df)
df <- data.frame(df[,c("conf1","conf2","conf3")],
behav.2 = ifelse(df$behav == 2, 1, 0),
behav.3 = ifelse(df$behav == 3, 1, 0),
env.2 = ifelse(df$env == 2, 1, 0),
env.3 = ifelse(df$env == 3, 1, 0),
hlth.outcome = df$hlth.outcome)
head(df)
# Define Q and g formulas
# an A1 * A2 interaction term is recommended in the Q formula for the estimation
# of interaction effects
Q_formulas = c(hlth.outcome="Q.kplus1 ~ conf1 + conf2 + conf3 + behav.2 * env.2 + behav.2 * env.3 + behav.3 * env.2 + behav.3 * env.3")
g_formulas = c("behav.2 ~ conf1 + conf2",
"behav.3 ~ conf1 + conf2 + behav.2",
"env.2 ~ conf1 + conf3",
"env.3 ~ conf1 + conf3 + env.2")
# Define SuperLearner libraries
SL.library = list(Q=list("SL.glm"),
g=list("SL.glm"))
# Estimate MSM parameters by IPTW and TMLE
interaction.ltmle <- int.ltmleMSM(data = df,
Qform = Q_formulas,
gform = g_formulas,
A1nodes = c("behav.2","behav.3"),
A2nodes = c("env.2","env.3"),
Vnodes = NULL,
Lnodes = NULL,
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
ltmle_MSM <- interaction.ltmle
estimator = "tmle"
data <- ltmle_MSM$data
if(estimator == "gcomp") {
try(if(ltmle_MSM$ltmle_MSM$gcomp == FALSE) stop("The ltmle function did not use the gcomp estimator, but the iptw +/- tmle estimator"))
beta <- ltmle_MSM$ltmle_MSM$beta
}
if(estimator == "iptw") {
try(if(ltmle_MSM$ltmle_MSM$gcomp == TRUE) stop("The ltmle function used the gcomp estimator"))
beta <- ltmle_MSM$ltmle_MSM$beta.iptw
IC <- ltmle_MSM$ltmle_MSM$IC.iptw
var_IC <- var(IC) / nrow(data)
}
if(estimator == "tmle") {
try(if(ltmle_MSM$ltmle_MSM$gcomp == TRUE) stop("The ltmle function used the gcomp estimator, tmle is not available"))
beta <- ltmle_MSM$ltmle_MSM$beta
IC <- ltmle_MSM$ltmle_MSM$IC
var_IC <- var(IC) / nrow(data)
}
## save results in 5 tables: probabilities, risk differences, relative risks, odds ratios and interactions
# interactions A1 * A2
if(is.null(ltmle_MSM$Vnodes)) {
probs <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$A2nodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$A2nodes) +
4)) # p, sd.p, p.lo, p.up
colnames(probs) <- c(ltmle_MSM$A1nodes, ltmle_MSM$A2nodes, "p", "sd.p", "p.lo", "p.up")
RD <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$A2nodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$A2nodes) +
length(ltmle_MSM$A1nodes) * 4 + # RD.A1
length(ltmle_MSM$A2nodes) * 4 )) # RD.A2
RD.A1.names <- NULL
for(i in 1:length(ltmle_MSM$A1nodes)) {
RD.A1.names <- c(RD.A1.names,
paste0("RD.",ltmle_MSM$A1nodes)[i],
paste0("sd.RD.",ltmle_MSM$A1nodes)[i],
paste0("lo.RD.",ltmle_MSM$A1nodes)[i],
paste0("up.RD.",ltmle_MSM$A1nodes)[i])
}
RD.A2.names <- NULL
for(i in 1:length(ltmle_MSM$A2nodes)) {
RD.A2.names <- c(RD.A2.names,
paste0("RD.",ltmle_MSM$A2nodes)[i],
paste0("sd.RD.",ltmle_MSM$A2nodes)[i],
paste0("lo.RD.",ltmle_MSM$A2nodes)[i],
paste0("up.RD.",ltmle_MSM$A2nodes)[i])
}
colnames(RD) <- c(ltmle_MSM$A1nodes, ltmle_MSM$A2nodes,
RD.A1.names,RD.A2.names)
rm(RD.A1.names,RD.A2.names)
RR <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$A2nodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$A2nodes) +
length(ltmle_MSM$A1nodes) * 4 + # RR.A1
length(ltmle_MSM$A2nodes) * 4 )) # RR.A2
RR.A1.names <- NULL
for(i in 1:length(ltmle_MSM$A1nodes)) {
RR.A1.names <- c(RR.A1.names,
paste0("RR.",ltmle_MSM$A1nodes)[i],
paste0("sd.lnRR.",ltmle_MSM$A1nodes)[i],
paste0("lo.RR.",ltmle_MSM$A1nodes)[i],
paste0("up.RR.",ltmle_MSM$A1nodes)[i])
}
RR.A2.names <- NULL
for(i in 1:length(ltmle_MSM$A2nodes)) {
RR.A2.names <- c(RR.A2.names,
paste0("RR.",ltmle_MSM$A2nodes)[i],
paste0("sd.lnRR.",ltmle_MSM$A2nodes)[i],
paste0("lo.RR.",ltmle_MSM$A2nodes)[i],
paste0("up.RR.",ltmle_MSM$A2nodes)[i])
}
colnames(RR) <- c(ltmle_MSM$A1nodes, ltmle_MSM$A2nodes,
RR.A1.names,RR.A2.names)
rm(RR.A1.names,RR.A2.names)
OR <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$A2nodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$A2nodes) +
length(ltmle_MSM$A1nodes) * 4 + # OR.A1
length(ltmle_MSM$A2nodes) * 4 )) # OR.A2
OR.A1.names <- NULL
for(i in 1:length(ltmle_MSM$A1nodes)) {
OR.A1.names <- c(OR.A1.names,
paste0("OR.",ltmle_MSM$A1nodes)[i],
paste0("sd.lnOR.",ltmle_MSM$A1nodes)[i],
paste0("lo.OR.",ltmle_MSM$A1nodes)[i],
paste0("up.OR.",ltmle_MSM$A1nodes)[i])
}
OR.A2.names <- NULL
for(i in 1:length(ltmle_MSM$A2nodes)) {
OR.A2.names <- c(OR.A2.names,
paste0("OR.",ltmle_MSM$A2nodes)[i],
paste0("sd.lnOR.",ltmle_MSM$A2nodes)[i],
paste0("lo.OR.",ltmle_MSM$A2nodes)[i],
paste0("up.OR.",ltmle_MSM$A2nodes)[i])
}
colnames(OR) <- c(ltmle_MSM$A1nodes, ltmle_MSM$A2nodes,
OR.A1.names,OR.A2.names)
rm(OR.A1.names,OR.A2.names)
int <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$A2nodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$A2nodes) +
3 * 4) ) # a.INT, RERI, m.INT
colnames(int) <- c(ltmle_MSM$A1nodes, ltmle_MSM$A2nodes,
"a.INT", "sd.a.INT", "lo.a.INT", "up.a.INT",
"RERI","sd.RERI","lo.RERI","up.RERI",
"m.INT", "sd.ln.m.INT", "lo.m.INT", "up.m.INT")
}
# effect of A1, modified by V
if(is.null(ltmle_MSM$A2nodes)) {
probs <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$Vnodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$Vnodes) +
4)) # p, sd.p, p.lo, p.up
colnames(probs) <- c(ltmle_MSM$A1nodes, ltmle_MSM$Vnodes, "p", "sd.p", "p.lo", "p.up")
RD <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$Vnodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$Vnodes) +
length(ltmle_MSM$A1nodes) * 4 + # RD.A1
length(ltmle_MSM$Vnodes) * 4 )) # RD.V
RD.A1.names <- NULL
for(i in 1:length(ltmle_MSM$A1nodes)) {
RD.A1.names <- c(RD.A1.names,
paste0("RD.",ltmle_MSM$A1nodes)[i],
paste0("sd.RD.",ltmle_MSM$A1nodes)[i],
paste0("lo.RD.",ltmle_MSM$A1nodes)[i],
paste0("up.RD.",ltmle_MSM$A1nodes)[i])
}
RD.V.names <- NULL
for(i in 1:length(ltmle_MSM$Vnodes)) {
RD.V.names <- c(RD.V.names,
paste0("RD.",ltmle_MSM$Vnodes)[i],
paste0("sd.RD.",ltmle_MSM$Vnodes)[i],
paste0("lo.RD.",ltmle_MSM$Vnodes)[i],
paste0("up.RD.",ltmle_MSM$Vnodes)[i])
}
colnames(RD) <- c(ltmle_MSM$A1nodes, ltmle_MSM$Vnodes,
RD.A1.names,RD.V.names)
rm(RD.A1.names,RD.V.names)
RR <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$Vnodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$Vnodes) +
length(ltmle_MSM$A1nodes) * 4 + # RR.A1
length(ltmle_MSM$Vnodes) * 4 )) # RR.A2
RR.A1.names <- NULL
for(i in 1:length(ltmle_MSM$A1nodes)) {
RR.A1.names <- c(RR.A1.names,
paste0("RR.",ltmle_MSM$A1nodes)[i],
paste0("sd.lnRR.",ltmle_MSM$A1nodes)[i],
paste0("lo.RR.",ltmle_MSM$A1nodes)[i],
paste0("up.RR.",ltmle_MSM$A1nodes)[i])
}
RR.V.names <- NULL
for(i in 1:length(ltmle_MSM$Vnodes)) {
RR.V.names <- c(RR.V.names,
paste0("RR.",ltmle_MSM$Vnodes)[i],
paste0("sd.lnRR.",ltmle_MSM$Vnodes)[i],
paste0("lo.RR.",ltmle_MSM$Vnodes)[i],
paste0("up.RR.",ltmle_MSM$Vnodes)[i])
}
colnames(RR) <- c(ltmle_MSM$A1nodes, ltmle_MSM$A2nodes,
RR.A1.names,RR.V.names)
rm(RR.A1.names,RR.V.names)
OR <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$Vnodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$Vnodes) +
length(ltmle_MSM$A1nodes) * 4 + # OR.A1
length(ltmle_MSM$Vnodes) * 4 )) # OR.A2
OR.A1.names <- NULL
for(i in 1:length(ltmle_MSM$A1nodes)) {
OR.A1.names <- c(OR.A1.names,
paste0("OR.",ltmle_MSM$A1nodes)[i],
paste0("sd.lnOR.",ltmle_MSM$A1nodes)[i],
paste0("lo.OR.",ltmle_MSM$A1nodes)[i],
paste0("up.OR.",ltmle_MSM$A1nodes)[i])
}
OR.V.names <- NULL
for(i in 1:length(ltmle_MSM$Vnodes)) {
OR.V.names <- c(OR.V.names,
paste0("OR.",ltmle_MSM$Vnodes)[i],
paste0("sd.lnOR.",ltmle_MSM$Vnodes)[i],
paste0("lo.OR.",ltmle_MSM$Vnodes)[i],
paste0("up.OR.",ltmle_MSM$Vnodes)[i])
}
colnames(OR) <- c(ltmle_MSM$A1nodes, ltmle_MSM$A2nodes,
OR.A1.names,OR.V.names)
rm(OR.A1.names,OR.V.names)
int <- matrix(NA,
nrow = (length(ltmle_MSM$A1nodes) + 1) * (length(ltmle_MSM$Vnodes) + 1),
ncol = (length(ltmle_MSM$A1nodes) + length(ltmle_MSM$Vnodes) +
3 * 4) ) # a.INT, RERI, m.INT
colnames(int) <- c(ltmle_MSM$A1nodes, ltmle_MSM$Vnodes,
"a.INT", "sd.a.INT", "lo.a.INT", "up.a.INT",
"RERI","sd.RERI","lo.RERI","up.RERI",
"m.INT", "sd.ln.m.INT", "lo.m.INT", "up.m.INT")
}
values.A1 <- matrix(0, nrow = length(ltmle_MSM$A1nodes) + 1, ncol = length(ltmle_MSM$A1nodes))
for(i in 1:length(ltmle_MSM$A1nodes)) {
values.A1[i + 1, i] <- 1
colnames(values.A1) <- ltmle_MSM$A1nodes
}
if(is.null(ltmle_MSM$Vnodes)) {
values.A2 <- matrix(0, nrow = length(ltmle_MSM$A2nodes) + 1, ncol = length(ltmle_MSM$A2nodes))
for(i in 1:length(ltmle_MSM$A2nodes)) {
values.A2[i + 1, i] <- 1
colnames(values.A2) <- ltmle_MSM$A2nodes
}
}
if(is.null(ltmle_MSM$A2nodes)) {
values.A2 <- matrix(0, nrow = length(ltmle_MSM$Vnodes) + 1, ncol = length(ltmle_MSM$Vnodes))
for(i in 1:length(ltmle_MSM$Vnodes)) {
values.A2[i + 1, i] <- 1
colnames(values.A2) <- ltmle_MSM$Vnodes
}
}
row <- 1
for(i in 1:nrow(values.A1)) {
for(j in 1:nrow(values.A2)) {
probs[row,1:(ncol(values.A1) + ncol(values.A2))] <- c(values.A1[i,],values.A2[j,])
RD[row,1:(ncol(values.A1) + ncol(values.A2))] <- c(values.A1[i,],values.A2[j,])
RR[row,1:(ncol(values.A1) + ncol(values.A2))] <- c(values.A1[i,],values.A2[j,])
int[row,1:(ncol(values.A1) + ncol(values.A2))] <- c(values.A1[i,],values.A2[j,])
row <- row + 1
}
}
regimes <- probs[,1:(ncol(values.A1) + ncol(values.A2))]
Xtemp <- model.matrix(as.formula(ltmle_MSM$working.msm), data = data.frame(regimes, Y = 1))
## probabilities
probs[,"p"] <- plogis(Xtemp %*% beta)
# grad.p <- list()
for(i in 1:nrow(probs)) {
grad.p <- Xtemp[i,] * probs[i,"p"] * (1 - probs[i,"p"])
probs[i,"sd.p"] <- sqrt(t(grad.p) %*% var_IC %*% grad.p)
probs[i,"p.lo"] <- probs[i,"p"] - qnorm(0.975) * probs[i,"sd.p"]
probs[i,"p.up"] <- probs[i,"p"] + qnorm(0.975) * probs[i,"sd.p"]
}
(dim(as.matrix(regimes[,colnames(values.A2)]))[2] == 1)
(dim(as.matrix(regimes[,colnames(values.A2)]))[2] > 1)
as.matrix(regimes[,colnames(values.A2)])
apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,])
apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod)
apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] == 1) {
cond2 = as.matrix(regimes[,colnames(values.A2)]) == values.A2[j,]
}
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] > 1) {
cond2 = t(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
}
i
j
i = 1
j = 1
t(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
as.matrix(regimes[,i] == 1)
apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1
as.matrix(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] == 1) {
cond2 = as.matrix(regimes[,colnames(values.A2)]) == values.A2[j,]
}
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] > 1) {
cond2 = as.matrix(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
}
which(as.matrix(regimes[,i] == 1) & cond2)
which(as.matrix(rowSums(as.matrix(regimes[,colnames(values.A1)])) == 0) & cond2)
j = 2
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] == 1) {
cond2 = as.matrix(regimes[,colnames(values.A2)]) == values.A2[j,]
}
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] > 1) {
cond2 = as.matrix(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
}
r.ind <- which(as.matrix(regimes[,i] == 1) & cond2)
r.ref <- which(as.matrix(rowSums(as.matrix(regimes[,colnames(values.A1)])) == 0) & cond2)
r.ind
r.ref
j = 3
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] == 1) {
cond2 = as.matrix(regimes[,colnames(values.A2)]) == values.A2[j,]
}
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] > 1) {
cond2 = as.matrix(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
}
r.ind <- which(as.matrix(regimes[,i] == 1) & cond2)
r.ref <- which(as.matrix(rowSums(as.matrix(regimes[,colnames(values.A1)])) == 0) & cond2)
r.ind
r.ref
i = 2
j = 1
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] == 1) {
cond2 = as.matrix(regimes[,colnames(values.A2)]) == values.A2[j,]
}
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] > 1) {
cond2 = as.matrix(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
}
r.ind <- which(as.matrix(regimes[,i] == 1) & cond2)
r.ref <- which(as.matrix(rowSums(as.matrix(regimes[,colnames(values.A1)])) == 0) & cond2)
r.ind
r.ref
j = 2
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] == 1) {
cond2 = as.matrix(regimes[,colnames(values.A2)]) == values.A2[j,]
}
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] > 1) {
cond2 = as.matrix(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
}
r.ind <- which(as.matrix(regimes[,i] == 1) & cond2)
r.ref <- which(as.matrix(rowSums(as.matrix(regimes[,colnames(values.A1)])) == 0) & cond2)
r.ind
r.ref
j =3
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] == 1) {
cond2 = as.matrix(regimes[,colnames(values.A2)]) == values.A2[j,]
}
if(dim(as.matrix(regimes[,colnames(values.A2)]))[2] > 1) {
cond2 = as.matrix(apply(apply(as.matrix(regimes[,colnames(values.A2)]), 1, function(r) r == values.A2[j,]),2,prod) == 1)
}
r.ind <- which(as.matrix(regimes[,i] == 1) & cond2)
r.ref <- which(as.matrix(rowSums(as.matrix(regimes[,colnames(values.A1)])) == 0) & cond2)
r.ind
r.ref
