use_readme_rmd()
library(devtools)
use_readme_rmd()
library(devtools)
load_all()
check()
library(ltmle)
library(ggplot2)
require(MargIntTmle)
set.seed(12345)
df <- generate.data(N = 1000, b = param.causal.model())
head(df)
require(ltmle)
require(SuperLearner)
Q_formulas = c(hlth.outcome="Q.kplus1 ~ conf1 + conf2 + conf3 + sex * env")
g_formulas = c("sex ~ conf1 + conf2","env ~ conf1 + conf3")
SL.library = list(Q=list("SL.glm"),g=list("SL.glm"))
interaction.ltmle <- int.ltmleMSM(data = df,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
est.tmle <- estim.int.effects(interaction.ltmle, estimator = "tmle")
est.tmle
table_inter <- out.int.table(int.r = est.tmle)
table_inter$out.table
table_inter$interaction.effects
library(kableExtra)
kbl(table_inter$out.table,
caption = "Interaction effects estimated by TMLE") %>%
kable_classic() %>%
footnote(general = table_inter$interaction.effects)
out.int.fig(est.tmle)
use_readme_rmd()
library(devtools)
use_readme_rmd()
load_all()
check()
install()
library(devtools)
build_readme()
library(devtools)
build_readme()
load_all()
build_readme()
load_all()
check()
load_all()
build_readme()
load_all()
check()
install()
library(devtools)
build_readme()
load_all()
check()
install()
library(devtools)
load_all()
load_all()
addition(2,2)
library(SuperLearner)
SL.glm
SL.glm.interaction
SL.step.interaction
require(MargIntTmle)
#> Le chargement a nécessité le package : MargIntTmle
set.seed(12345)
df <- generate.data(N = 1000, b = param.causal.model())
head(df)
require(SuperLearner)
# define Q and g formulas following the argument notation of the ltmle package:
Q_formulas = c(hlth.outcome="Q.kplus1 ~ conf1 + conf2 + conf3 + sex * env")
g_formulas = c("sex ~ conf1 + conf2","env ~ conf1 + conf3")
# choose a set of fitting libraries to pass to SuperLearner:
SL.library = list(Q=list("SL.glm"),g=list("SL.glm"))
# apply the int.ltmleMSM function. In order to apply the TMLE and IPTW estimators,
# gcomp argument is set to FALSE.
interaction.ltmle <- int.ltmleMSM(data = df,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
interaction.ltmle$ltmle_MSM
SL.library = list(Q=list("SL.mean","SL.glm", "SL.ranger"),g=list("SL.mean","SL.glm", "SL.ranger"))
# apply the int.ltmleMSM function. In order to apply the TMLE and IPTW estimators,
# gcomp argument is set to FALSE.
interaction.ltmle <- int.ltmleMSM(data = df,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
interaction.ltmle$ltmle_MSM$fit
interaction.ltmle$ltmle_MSM$fit$Q
usethis::create_from_github("https://github.com/benoitlepage/mediation_workshop.git","C:/Users/Benoit/Documents/Toulouse/Git repositories/")
gitcreds::gitcreds_set()
library(ctmle)
set.seed(123)
N <- 1000
p = 5
Wmat <- matrix(rnorm(N * p), ncol = p) # 5 variables baselines normales, indépendantes
beta1 <- 4 + 2 * Wmat[,1] + 2 * Wmat[,2] + 2 * Wmat[,5]
beta0 <- 2 + 2 * Wmat[,1] + 2 * Wmat[,2] + 2 * Wmat[,5]
tau <- 2  # true effect
gcoef <- matrix(c(-1, -1, rep(-(3/((p) - 2)),(p) - 2)),ncol=1)
W <- as.matrix(Wmat)
g <- 1/(1+exp(W%*%gcoef /3))
A <- rbinom(N, 1, prob = g)
epsilon <-rnorm(N, 0, 1)
Y  <- beta0 + tau * A + epsilon
head(Wmat)
gcoef
rm(list=ls())
set.seed(123)
N <- 1000
p = 5
Wmat <- matrix(rnorm(N * p), ncol = p) # 5 variables baselines normales, indépendantes
head(Wmat)
#             [,1]        [,2]       [,3]        [,4]       [,5]
# [1,] -0.56047565 -0.99579872 -0.5116037 -0.15030748  0.1965498
# [2,] -0.23017749 -1.03995504  0.2369379 -0.32775713  0.6501132
# [3,]  1.55870831 -0.01798024 -0.5415892 -1.44816529  0.6710042
# [4,]  0.07050839 -0.13217513  1.2192276 -0.69728458 -1.2841578
# [5,]  0.12928774 -2.54934277  0.1741359  2.59849023 -2.0261096
# [6,]  1.71506499  1.04057346 -0.6152683 -0.03741501  2.2053261
beta1 <- 4 + 2 * Wmat[,1] + 2 * Wmat[,2] + 2 * Wmat[,5]
beta0 <- 2 + 2 * Wmat[,1] + 2 * Wmat[,2] + 2 * Wmat[,5]
tau <- 2  # true effect
gcoef <- matrix(c(-1, -1, rep(-(3/((p) - 2)),(p) - 2)),ncol=1)
rep(-(3/((p) - 2))
rep(-(3/((p) - 2)), (p) - 2)
rep(-(3/((p) - 2)), (p) - 2))
(3/((p) - 2))
-(3/((p) - 2))
rep(-(3/((p) - 2)), (p) - 2)
library(ctmle)
library(dplyr)
### simulate dataset
rm(list=ls())
set.seed(123)
N <- 1000
p = 5
Wmat <- matrix(rnorm(N * p), ncol = p) # 5 variables baselines normales, indépendantes
head(Wmat)
#             [,1]        [,2]       [,3]        [,4]       [,5]
# [1,] -0.56047565 -0.99579872 -0.5116037 -0.15030748  0.1965498
# [2,] -0.23017749 -1.03995504  0.2369379 -0.32775713  0.6501132
# [3,]  1.55870831 -0.01798024 -0.5415892 -1.44816529  0.6710042
# [4,]  0.07050839 -0.13217513  1.2192276 -0.69728458 -1.2841578
# [5,]  0.12928774 -2.54934277  0.1741359  2.59849023 -2.0261096
# [6,]  1.71506499  1.04057346 -0.6152683 -0.03741501  2.2053261
beta1 <- 4 + 2 * Wmat[,1] + 2 * Wmat[,2] + 2 * Wmat[,5]
beta0 <- 2 + 2 * Wmat[,1] + 2 * Wmat[,2] + 2 * Wmat[,5]
tau <- 2  # true effect
gcoef <- matrix(c(-1, -1, rep(-(3/((p) - 2)), (p) - 2) ), ncol=1)
#      [,1]
# [1,]   -1
# [2,]   -1
# [3,]   -1
# [4,]   -1
# [5,]   -1
W <- as.matrix(Wmat)
# g()
g <- 1 / (1 + exp( W %*% gcoef / 3) ) # probabilité prédite par un modèle logistique où chaque W a un coefficient égale à -1/3 et un intercept = 0
A <- rbinom(N, 1, prob = g)
epsilon <-rnorm(N, 0, 1)
# Q_bar
Y  <- beta0 + tau * A + epsilon
# With initial estimate of Q = la valeur de Y chez les individus exposés au niveau d'intérêt : A=0 ou A=1
Q <- cbind(rep(mean(Y[A == 0]), N),
rep(mean(Y[A == 1]), N))
time_greedy <- system.time(
ctmle_discrete_fit1 <- ctmleDiscrete(Y = Y,
A = A,
W = data.frame(Wmat),
Q = Q,
preOrder = FALSE, # greedy
detailed = TRUE)
)
ctmle_discrete_fit2 <- ctmleDiscrete(Y = Y, A = A, W = data.frame(Wmat),
preOrder = FALSE, detailed = TRUE)
### simulate dataset
rm(list=ls())
set.seed(123)
N <- 1000
p = 5
Wmat <- matrix(rnorm(N * p), ncol = p) # 5 variables baselines normales, indépendantes
head(Wmat)
#             [,1]        [,2]       [,3]        [,4]       [,5]
# [1,] -0.56047565 -0.99579872 -0.5116037 -0.15030748  0.1965498
# [2,] -0.23017749 -1.03995504  0.2369379 -0.32775713  0.6501132
# [3,]  1.55870831 -0.01798024 -0.5415892 -1.44816529  0.6710042
# [4,]  0.07050839 -0.13217513  1.2192276 -0.69728458 -1.2841578
# [5,]  0.12928774 -2.54934277  0.1741359  2.59849023 -2.0261096
# [6,]  1.71506499  1.04057346 -0.6152683 -0.03741501  2.2053261
beta1 <- 4 + 2 * Wmat[,1] + 2 * Wmat[,2] + 2 * Wmat[,5]
beta0 <- 2 + 2 * Wmat[,1] + 2 * Wmat[,2] + 2 * Wmat[,5]
tau <- 2  # true effect
gcoef <- matrix(c(-1, -1, rep(-(3/((p) - 2)), (p) - 2) ), ncol=1)
#      [,1]
# [1,]   -1
# [2,]   -1
# [3,]   -1
# [4,]   -1
# [5,]   -1
W <- as.matrix(Wmat)
# g()
g <- 1 / (1 + exp( W %*% gcoef / 3) ) # probabilité prédite par un modèle logistique où chaque W a un coefficient égale à -1/3 et un intercept = 0
A <- rbinom(N, 1, prob = g)
epsilon <-rnorm(N, 0, 1)
# Q_bar
Y  <- beta0 + tau * A + epsilon
# With initial estimate of Q = la valeur de Y chez les individus exposés au niveau d'intérêt : A=0 ou A=1
Q <- cbind(rep(mean(Y[A == 0]), N),
rep(mean(Y[A == 1]), N))
time_greedy <- system.time(
ctmle_discrete_fit1 <- ctmleDiscrete(Y = Y,
A = A,
W = data.frame(Wmat),
Q = Q, # nx2 matrix of initial values for Q0W, Q1W in columns 1 and 2 respectively. Current version does not support SL for automatic initial estimation of Q bar
preOrder = FALSE, # greedy
detailed = TRUE)
)
ctmle_discrete_fit2 <- ctmleDiscrete(Y = Y, # ici, on ne précise pas la initial estimate of Q ??
A = A,
W = data.frame(Wmat),
preOrder = FALSE, # greedy,
detailed = TRUE)
time_preorder <- system.time(
ctmle_discrete_fit3 <- ctmleDiscrete(Y = Y,
A = A,
W = data.frame(Wmat),
Q = Q,
preOrder = TRUE, # use scalable C-TMLE
order = rev(1:p),
detailed = TRUE)
)
time_greedy
time_preorder
ctmle_discrete_fit1
summary(ctmle_discrete_fit1)
summary(ctmle_discrete_fit2)
summary(ctmle_discrete_fit3)
set.seed(123)
N <- 1000
p = 100
Wmat <- matrix(rnorm(N * p), ncol = p)
beta1 <- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 <- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
tau <- 2
gcoef <- matrix(c(-1,-1,rep(-(3/((p)-2)),(p)-2)),ncol=1)
W <- as.matrix(Wmat)
g <- 1/(1+exp(W%*%gcoef /3))
A <- rbinom(N, 1, prob = g)
epsilon <-rnorm(N, 0, 1)
Y  <- beta0 + tau * A + epsilon
# With initial estimate of Q
Q <- cbind(rep(mean(Y[A == 0]), N),
rep(mean(Y[A == 1]), N))
glmnet_fit <- cv.glmnet(y = A, # fonction g
x = W,
family = 'binomial',
nlambda = 20)
glmnet_fit
glmnet_fit$lambda
glmnet_fit$glmnet.fit
set.seed(123)
N <- 1000
p = 100
Wmat <- matrix(rnorm(N * p), ncol = p)
beta1 <- 4+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
beta0 <- 2+2*Wmat[,1]+2*Wmat[,2]+2*Wmat[,5]+2*Wmat[,6]+2*Wmat[,8]
tau <- 2
gcoef <- matrix(c(-1,-1,rep(-(3/((p)-2)),(p)-2)),ncol=1)
W <- as.matrix(Wmat)
g <- 1/(1+exp(W%*%gcoef /3))
A <- rbinom(N, 1, prob = g)
epsilon <-rnorm(N, 0, 1)
Y  <- beta0 + tau * A + epsilon
# With initial estimate of Q
Q <- cbind(rep(mean(Y[A == 0]), N),
rep(mean(Y[A == 1]), N))
glmnet_fit <- cv.glmnet(y = A, # fonction g régression logistique lasso
x = W,
family = 'binomial',
nlambda = 20)
# We suggest start build a sequence of lambdas from the lambda selected by cross-validation,
# as the model selected by cv.glmnet would over-smooth w.r.t. the target parameter.
lambdas <-glmnet_fit$lambda[(which(glmnet_fit$lambda==glmnet_fit$lambda.min)):length(glmnet_fit$lambda)]
# We fit C-TMLE1 algorithm by feed the algorithm with a vector of lambda, in decreasing order:
time_ctmlelasso1 <- system.time(
ctmle_fit1 <- ctmleGlmnet(Y = Y,
A = A,
W = data.frame(W = W),
Q = Q,
lambdas = lambdas,
ctmletype=1,
family="gaussian",
gbound=0.025,
V=5)
)
# We fit C-TMLE2 algorithm
time_ctmlelasso2 <- system.time(
ctmle_fit2 <- ctmleGlmnet(Y = Y,
A = A,
W = data.frame(W = W),
Q = Q,
lambdas = lambdas,
ctmletype=2,
family="gaussian",
gbound=0.025,
V=5)
)
# For C-TMLE3, we need two gn estimators, one with lambda selected by cross-validation,
# and the other with lambda slightly different from the selected lambda
gcv <- stats::predict(glmnet_fit, newx=W, s="lambda.min",type="response")
gcv <- bound(gcv,c(0.025,0.975))
s_prev <- glmnet_fit$lambda[(which(glmnet_fit$lambda == glmnet_fit$lambda.min))] * (1+5e-2)
gcvPrev <- stats::predict(glmnet_fit,newx = W,s = s_prev,type="response")
gcvPrev <- bound(gcvPrev,c(0.025,0.975))
time_ctmlelasso3 <- system.time(
ctmle_fit3 <- ctmleGlmnet(Y = Y, A = A, W = W, Q = Q,
ctmletype=3, g1W = gcv, g1WPrev = gcvPrev,
family="gaussian",
gbound=0.025, V = 5)
)
# Les't compare the running time for each LASSO-C-TMLE
time_ctmlelasso1
time_ctmlelasso2
time_ctmlelasso3
ctmle_fit1
ctmle_fit2
ctmle_fit3
lambdas[ctmle_fit1$best_k]
glmnet_fit$lambda.min
devtools::install_github("benoitlepage/MargIntTmle")
packageVersion("devtools")
install.packages(c("attention", "bartMachine", "blob", "bookdown", "broom", "broom.helpers", "cachem", "car", "caret", "checkmate", "classInt", "cli", "commonmark", "data.table", "dbplyr", "DescTools", "dplyr", "dtplyr", "evaluate", "fastmap", "flextable", "fma", "fontawesome", "forecast", "Formula", "fpp2", "fs", "future", "gam", "gargle", "gdtools", "ggdag", "ggplot2", "ggpubr", "ggsci", "gh", "glmnet", "Gmisc", "googledrive", "googlesheets4", "graphlayouts", "gt", "gtable", "gtsummary", "h2o", "hardhat", "haven", "Hmisc", "hms", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "interp", "ipred", "keras", "labelled", "later", "lava", "lme4", "ltmle", "lubridate", "markdown", "MASS", "Matrix", "metafor", "microbenchmark", "modelr", "multcomp", "officer", "openssl", "packrat", "pak", "parallelly", "pillar", "processx", "prodlim", "profvis", "ps", "psych", "quantmod", "quantreg", "ranger", "raster", "RcppArmadillo", "RCurl", "readr", "readxl", "recipes", "rgdal", "rgeos", "rlang", "rmarkdown", "rms", "rnn", "s2", "sass", "sf", "SnowballC", "speedglm", "styler", "survey", "terra", "testthat", "TH.data", "tibble", "tidyverse", "tinytex", "triebeard", "truncnorm", "tseries", "tsfgrnn", "units", "V8", "vctrs", "VGAM", "viridis", "viridisLite", "vroom", "waldo", "wk", "xfun", "xgboost", "XML", "xml2", "xts", "zip", "zoo"))
install.packages(c("attention", "bartMachine", "blob", "bookdown", "broom", "broom.helpers", "cachem", "car", "caret", "checkmate", "classInt", "cli", "commonmark", "data.table", "dbplyr", "DescTools", "dplyr", "dtplyr", "evaluate", "fastmap", "flextable", "fma", "fontawesome", "forecast", "Formula", "fpp2", "fs", "future", "gam", "gargle", "gdtools", "ggdag", "ggplot2", "ggpubr", "ggsci", "gh", "glmnet", "Gmisc", "googledrive", "googlesheets4", "graphlayouts", "gt", "gtable", "gtsummary", "h2o", "hardhat", "haven", "Hmisc", "hms", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "interp", "ipred", "keras", "labelled", "later", "lava", "lme4", "ltmle", "lubridate", "markdown", "MASS", "Matrix", "metafor", "microbenchmark", "modelr", "multcomp", "officer", "openssl", "packrat", "pak", "parallelly", "pillar", "processx", "prodlim", "profvis", "ps", "psych", "quantmod", "quantreg", "ranger", "raster", "RcppArmadillo", "RCurl", "readr", "readxl", "recipes", "rgdal", "rgeos", "rlang", "rmarkdown", "rms", "rnn", "s2", "sass", "sf", "SnowballC", "speedglm", "styler", "survey", "terra", "testthat", "TH.data", "tibble", "tidyverse", "tinytex", "triebeard", "truncnorm", "tseries", "tsfgrnn", "units", "V8", "vctrs", "VGAM", "viridis", "viridisLite", "vroom", "waldo", "wk", "xfun", "xgboost", "XML", "xml2", "xts", "zip", "zoo"))
install.packages(c("attention", "bartMachine", "blob", "bookdown", "broom", "broom.helpers", "cachem", "car", "caret", "checkmate", "classInt", "cli", "commonmark", "data.table", "dbplyr", "DescTools", "dplyr", "dtplyr", "evaluate", "fastmap", "flextable", "fma", "fontawesome", "forecast", "Formula", "fpp2", "fs", "future", "gam", "gargle", "gdtools", "ggdag", "ggplot2", "ggpubr", "ggsci", "gh", "glmnet", "Gmisc", "googledrive", "googlesheets4", "graphlayouts", "gt", "gtable", "gtsummary", "h2o", "hardhat", "haven", "Hmisc", "hms", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "interp", "ipred", "keras", "labelled", "later", "lava", "lme4", "ltmle", "lubridate", "markdown", "MASS", "Matrix", "metafor", "microbenchmark", "modelr", "multcomp", "officer", "openssl", "packrat", "pak", "parallelly", "pillar", "processx", "prodlim", "profvis", "ps", "psych", "quantmod", "quantreg", "ranger", "raster", "RcppArmadillo", "RCurl", "readr", "readxl", "recipes", "rgdal", "rgeos", "rlang", "rmarkdown", "rms", "rnn", "s2", "sass", "sf", "SnowballC", "speedglm", "styler", "survey", "terra", "testthat", "TH.data", "tibble", "tidyverse", "tinytex", "triebeard", "truncnorm", "tseries", "tsfgrnn", "units", "V8", "vctrs", "VGAM", "viridis", "viridisLite", "vroom", "waldo", "wk", "xfun", "xgboost", "XML", "xml2", "xts", "zip", "zoo"))
install.packages(c("attention", "bartMachine", "blob", "bookdown", "broom", "broom.helpers", "cachem", "car", "caret", "checkmate", "classInt", "cli", "commonmark", "data.table", "dbplyr", "DescTools", "dplyr", "dtplyr", "evaluate", "fastmap", "flextable", "fma", "fontawesome", "forecast", "Formula", "fpp2", "fs", "future", "gam", "gargle", "gdtools", "ggdag", "ggplot2", "ggpubr", "ggsci", "gh", "glmnet", "Gmisc", "googledrive", "googlesheets4", "graphlayouts", "gt", "gtable", "gtsummary", "h2o", "hardhat", "haven", "Hmisc", "hms", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "interp", "ipred", "keras", "labelled", "later", "lava", "lme4", "ltmle", "lubridate", "markdown", "MASS", "Matrix", "metafor", "microbenchmark", "modelr", "multcomp", "officer", "openssl", "packrat", "pak", "parallelly", "pillar", "processx", "prodlim", "profvis", "ps", "psych", "quantmod", "quantreg", "ranger", "raster", "RcppArmadillo", "RCurl", "readr", "readxl", "recipes", "rgdal", "rgeos", "rlang", "rmarkdown", "rms", "rnn", "s2", "sass", "sf", "SnowballC", "speedglm", "styler", "survey", "terra", "testthat", "TH.data", "tibble", "tidyverse", "tinytex", "triebeard", "truncnorm", "tseries", "tsfgrnn", "units", "V8", "vctrs", "VGAM", "viridis", "viridisLite", "vroom", "waldo", "wk", "xfun", "xgboost", "XML", "xml2", "xts", "zip", "zoo"))
install.packages(c("attention", "bartMachine", "blob", "bookdown", "broom", "broom.helpers", "cachem", "car", "caret", "checkmate", "classInt", "cli", "commonmark", "data.table", "dbplyr", "DescTools", "dplyr", "dtplyr", "evaluate", "fastmap", "flextable", "fma", "fontawesome", "forecast", "Formula", "fpp2", "fs", "future", "gam", "gargle", "gdtools", "ggdag", "ggplot2", "ggpubr", "ggsci", "gh", "glmnet", "Gmisc", "googledrive", "googlesheets4", "graphlayouts", "gt", "gtable", "gtsummary", "h2o", "hardhat", "haven", "Hmisc", "hms", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "interp", "ipred", "keras", "labelled", "later", "lava", "lme4", "ltmle", "lubridate", "markdown", "MASS", "Matrix", "metafor", "microbenchmark", "modelr", "multcomp", "officer", "openssl", "packrat", "pak", "parallelly", "pillar", "processx", "prodlim", "profvis", "ps", "psych", "quantmod", "quantreg", "ranger", "raster", "RcppArmadillo", "RCurl", "readr", "readxl", "recipes", "rgdal", "rgeos", "rlang", "rmarkdown", "rms", "rnn", "s2", "sass", "sf", "SnowballC", "speedglm", "styler", "survey", "terra", "testthat", "TH.data", "tibble", "tidyverse", "tinytex", "triebeard", "truncnorm", "tseries", "tsfgrnn", "units", "V8", "vctrs", "VGAM", "viridis", "viridisLite", "vroom", "waldo", "wk", "xfun", "xgboost", "XML", "xml2", "xts", "zip", "zoo"))
install.packages(c("cli", "Hmisc", "httpuv", "rlang", "rms"))
install.packages(c("cli", "Hmisc", "httpuv", "rlang", "rms"))
