# regime=
# binary array: n x numAnodes x numRegimes of counterfactual treatment or a list of 'rule' functions
# colnames(regime) should be the same as Anodes (in the same order)
regimes.MSM <- array(NA, dim = c(nrow(data), numAnodes, nb.regimes))
for(i in 1:nb.regimes) {
for(r in 1:nrow(data)) {
regimes.MSM[r,,i] <- summary.measures.reg[i,1:numAnodes,1]
}
}
colnames(regimes.MSM) <- A1nodes
}
# A1node.matrix <- matrix(0, nrow = (length(A1nodes) + 1), ncol = length(A1nodes))
# for(i in 1:ncol(A1node.matrix)) {
#   A1node.matrix[i+1,i] <- 1
# }
# colnames(A1node.matrix) <- A1nodes
# A2node.matrix <- matrix(0, nrow = (length(A2nodes) + 1), ncol = length(A2nodes))
# for(i in 1:ncol(A2node.matrix)) {
#   A2node.matrix[i+1,i] <- 1
# }
# colnames(A2node.matrix) <- A2nodes
#
#
#
# Anode.matrix <- matrix(NA, nrow = 0, #nrow = nrow(A1node.matrix) * nrow(A2node.matrix),
#                        ncol = length(A1nodes) * length(A2nodes))
# for(i in 1:nrow(A1node.matrix)) {
#   for(j in 1:nrow(A2node.matrix)) {
#     Anode.matrix <- rbind(Anode.matrix,
#                           c(A1node.matrix[i,],A2node.matrix[j,]))
#   }
# }
# for(i in 1:length(A1nodes)) {
#   for(j in (length(A1nodes) +1):(length(A1nodes) + length(A2nodes))) {
#     Anode.matrix <- cbind(Anode.matrix,
#                           as.data.frame(Anode.matrix)[,i] * as.data.frame(Anode.matrix)[,j])
#   }
# }
if(gcomp == TRUE) {
# test length SL.library$Q
SL.library$Q <- ifelse(length(SL.library$Q) > 1, "glm", SL.library$Q) # +++++ DELETE +++++++++++ ?????
# simplify SL.library$g because g functions are useless with g-computation
SL.library$g <- "SL.mean"
iptw.only <- FALSE
}
ltmle_MSM <- ltmle::ltmleMSM(data = data,
Anodes = Anodes,
Cnodes = Cnodes,
Lnodes = c(interm.Lnodes),
Ynodes = Ynodes,
survivalOutcome = survivalOutcome,
Qform = Qform,
gform = gform,
gbounds = gbounds,
Yrange = Yrange,
deterministic.g.function = deterministic.g.function,
SL.library = SL.library,
SL.cvControl = SL.cvControl,
regimes = regimes.MSM, # instead of abar
working.msm= working.msm,
summary.measures = summary.measures.reg,
final.Ynodes = final.Ynodes,
stratify = stratify,
msm.weights = msm.weights,
estimate.time = estimate.time,
gcomp = gcomp,
iptw.only = iptw.only,
deterministic.Q.function = deterministic.Q.function,
variance.method = variance.method,
observation.weights = observation.weights,
id = id)
bootstrap.res <- NULL
if(gcomp == TRUE) {
# bootstrap.res <- data.frame("beta.Intercept" = rep(NA, B),
#                             "beta.A1" = rep(NA, B),
#                             "beta.A2" = rep(NA, B),
#                             "beta.A1A2" = rep(NA, B))
bootstrap.res.list <- list()
if (is.null(boot.seed)) {
print("boot.seed argument is null, please add a seed in the int.ltmleMSM function")}
set.seed <- boot.seed
for (b in 1:B){
# sample the indices 1 to n with replacement
bootIndices <- sample(1:nrow(data), replace=T)
bootData <- data[bootIndices,]
if ( round(b/100, 0) == b/100 ) print(paste0("bootstrap number ",b))
suppressMessages(boot_ltmle_MSM <- ltmle::ltmleMSM(data = bootData,
Anodes = Anodes,
Cnodes = Cnodes,
Lnodes = c(interm.Lnodes),
Ynodes = Ynodes,
survivalOutcome = survivalOutcome,
Qform = Qform,
gform = gform,
gbounds = gbounds,
Yrange = Yrange,
deterministic.g.function = deterministic.g.function,
SL.library = SL.library,
SL.cvControl = SL.cvControl,
regimes = regimes.MSM, # instead of abar
working.msm= working.msm,
summary.measures = summary.measures.reg,
final.Ynodes = final.Ynodes,
stratify = stratify,
msm.weights = msm.weights,
estimate.time = estimate.time,
gcomp = gcomp,
iptw.only = iptw.only,
deterministic.Q.function = deterministic.Q.function,
variance.method = variance.method,
observation.weights = observation.weights,
id = id))
bootstrap.res.list[[b]] <- boot_ltmle_MSM$beta
}
bootstrap.res <- matrix(NA, nrow = B, ncol = length(bootstrap.res.list[[1]]))
for(b in 1:B) {
for(i in 1:length(bootstrap.res.list[[1]])) {
bootstrap.res[b,i] <- bootstrap.res.list[[b]][i]
}
}
colnames(bootstrap.res) <- names(boot_ltmle_MSM$beta)
bootstrap.res <- data.frame(bootstrap.res)
}
return(list(ltmle_MSM = ltmle_MSM,
working.msm = working.msm,
data = data,
A1nodes = A1nodes,
A2nodes = A2nodes,
Vnodes = Vnodes,
Ynodes = Ynodes,
bootstrap.res = bootstrap.res))
}
out.int.table <- function(int.r = int.r,
probab.digits = 3,
RR.OR.digits = 2,
multipl = c("RR"), # "RR" or "OR"
labels.A1 = NULL,
labels.A2 = NULL,
labels.V = NULL) {
if(is.null(int.r$A2nodes)) {
A2nodes <- int.r$Vnodes
labels.A2 <- labels.V
values.A2 <- int.r$values.V
}
if(is.null(int.r$Vnodes)) {
A2nodes <- int.r$A2nodes
values.A2 <- int.r$values.A2
}
if(multipl == "RR") {
XR <- int.r$RR
}
if(multipl == "OR") {
XR <- int.r$OR
}
## reference level
if(ncol(labels.A1) == 1) {
ref.A1 <- labels.A1[rowSums(labels.A1) == 0, ncol(labels.A1)]
}
if(ncol(labels.A1) > 1) {
ref.A1 <- labels.A1[rowSums(labels.A1[,-ncol(labels.A1)]) == 0, ncol(labels.A1)]
}
if(ncol(labels.A2) == 1) {
ref.A2 <- labels.A2[rowSums(labels.A2) == 0, ncol(labels.A2)]
}
if(ncol(labels.A2) > 1) {
ref.A2 <- labels.A2[rowSums(labels.A2[,-ncol(labels.A2)]) == 0, ncol(labels.A2)]
}
##  table of marginal effects (with A2 or V nodes displayed by column)
out.table <- data.frame(matrix("", nrow = (length(int.r$A1nodes) + 1) + (length(int.r$A1nodes) * 2),
ncol = (length(A2nodes) + 1) + (length(A2nodes) * 2)) )
names.A1 <- paste0(names(labels.A1)[ncol(labels.A1)],"=",labels.A1[,ncol(labels.A1)])
if(ncol(labels.A1) == 1) {
names.RD.A1 <- paste0("RD.",names(labels.A1)[ncol(labels.A1)],"=",
labels.A1[rowSums(labels.A1)!=0, ncol(labels.A1)]," vs.",ref.A1,
"|",names(labels.A2)[ncol(labels.A2)])
names.RR.A1 <- paste0(multipl,".",names(labels.A1)[ncol(labels.A1)],"=",
labels.A1[rowSums(labels.A1)!=0,ncol(labels.A1)]," vs.",ref.A1,
"|",names(labels.A2)[ncol(labels.A2)])
}
if(ncol(labels.A1) > 1) {
names.RD.A1 <- paste0("RD.",names(labels.A1)[ncol(labels.A1)],"=",
labels.A1[rowSums(labels.A1[,1:(ncol(labels.A1)-1)])!=0,
ncol(labels.A1)]," vs.",ref.A1,
"|",names(labels.A2)[ncol(labels.A2)])
names.RR.A1 <- paste0(multipl,".",names(labels.A1)[ncol(labels.A1)],"=",
labels.A1[rowSums(labels.A1[,1:(ncol(labels.A1)-1)])!=0,
ncol(labels.A1)]," vs.",ref.A1,
"|",names(labels.A2)[ncol(labels.A2)])
}
names.A2 <- paste0(names(labels.A2)[ncol(labels.A2)],"=",labels.A2[,ncol(labels.A2)])
if(ncol(labels.A2) == 1) {
names.RD.A2 <- paste0("RD.",names(labels.A2)[ncol(labels.A2)],"=",
labels.A2[rowSums(labels.A2)!=0, ncol(labels.A2)]," vs.",ref.A2,
"|",names(labels.A1)[ncol(labels.A1)])
names.RR.A2 <- paste0(multipl,".",names(labels.A2)[ncol(labels.A2)],"=",
labels.A2[rowSums(labels.A2)!=0, ncol(labels.A2)]," vs.",ref.A2,
"|",names(labels.A1)[ncol(labels.A1)])
}
if(ncol(labels.A2) > 1) {
names.RD.A2 <- paste0("RD.",names(labels.A2)[ncol(labels.A2)],"=",
labels.A2[rowSums(labels.A2[,1:(ncol(labels.A2)-1)])!=0,
ncol(labels.A2)]," vs.",ref.A2,
"|",names(labels.A1)[ncol(labels.A1)])
names.RR.A2 <- paste0(multipl,".",names(labels.A2)[ncol(labels.A2)],"=",
labels.A2[rowSums(labels.A2[,1:(ncol(labels.A2)-1)])!=0,
ncol(labels.A2)]," vs.",ref.A2,
"|",names(labels.A1)[ncol(labels.A1)])
}
names(out.table) <-c(names.A2, names.RD.A2, names.RR.A2)
rownames(out.table) <- c(names.A1, names.RD.A1, names.RR.A1)
int_res = int.r$int
# p
for(r in 1:nrow(labels.A1)) {
for(c in 1:nrow(labels.A2)) {
if(ncol(labels.A1) == 1) {
index.A1 <- int.r$probs[,names(labels.A1)] == labels.A1[r,]
}
if(ncol(labels.A1) > 1) {
index.A1 <- apply(apply(int.r$probs[,names(labels.A1)[-ncol(labels.A1)]], 1, function(row) row == labels.A1[r,-ncol(labels.A1)]),2,prod) == 1
}
if(ncol(labels.A2) == 1) {
index.A2 <- int.r$probs[,names(labels.A2)] == labels.A2[c,]
}
if(ncol(labels.A2) > 1) {
index.A2 <- apply(apply(int.r$probs[,names(labels.A2)[-ncol(labels.A2)]], 1, function(row) row == labels.A2[c,-ncol(labels.A2)]),2,prod) == 1
}
p <- int.r$probs[index.A1 & index.A2,"p"]
p.lo <- int.r$probs[index.A1 & index.A2,"p.lo"]
p.up <- int.r$probs[index.A1 & index.A2,"p.up"]
out.table[r,c] <- paste0(round(p, digits = probab.digits),
" [",
round(p.lo, digits = probab.digits),
",",
round(p.up, digits = probab.digits),
"]")
rm(index.A1, index.A2, p, p.lo, p.up)
}
}
# RD.A1
for(i in 1:ncol(int.r$values.A1)) {
index.col <- length(int.r$A1nodes) + length(A2nodes) + 4 * (i - 1) + 1
for(j in 1:nrow(labels.A2)) {
index.A1 <- int.r$RD[,colnames(int.r$values.A1)[i]] == 1
if(ncol(labels.A2) == 1) {
index.A2 <- int.r$RD[,names(labels.A2)] == labels.A2[j,]
}
if(ncol(labels.A2) > 1) {
index.A2 <- apply(apply(int.r$RD[,names(labels.A2)[-ncol(labels.A2)]], 1, function(row) row == labels.A2[j,-ncol(labels.A2)]),2,prod) == 1
}
RD <- int.r$RD[index.A1 & index.A2, index.col]
lo.RD <- int.r$RD[index.A1 & index.A2, index.col + 2]
up.RD <- int.r$RD[index.A1 & index.A2, index.col + 3]
out.table[nrow(int.r$values.A1) + i, j] <- paste0(round(RD, digits = probab.digits),
" [",
round(lo.RD, digits = probab.digits),
",",
round(up.RD, digits = probab.digits),
"]")
rm(index.A1, index.A2, RD, lo.RD, up.RD)
}
}
# RD.A2
for(i in 1:ncol(values.A2)) {
index.col <- length(int.r$A1nodes) + length(A2nodes) + 4 * length(int.r$A1nodes) + 4 * (i - 1) + 1
for(j in 1:nrow(labels.A1)) {
if(ncol(labels.A1) == 1) {
index.A1 <- int.r$RD[,names(labels.A1)] == labels.A1[j,]
}
if(ncol(labels.A1) > 1) {
index.A1 <- apply(apply(int.r$RD[,names(labels.A1)[-ncol(labels.A1)]], 1, function(row) row == labels.A1[j,-ncol(labels.A1)]),2,prod) == 1
}
index.A2 <- int.r$RD[,colnames(values.A2)[i]] == 1
RD <- int.r$RD[index.A1 & index.A2, index.col]
lo.RD <- int.r$RD[index.A1 & index.A2, index.col + 2]
up.RD <- int.r$RD[index.A1 & index.A2, index.col + 3]
out.table[j, nrow(values.A2) + i] <- paste0(round(RD, digits = probab.digits),
" [",
round(lo.RD, digits = probab.digits),
",",
round(up.RD, digits = probab.digits),
"]")
rm(index.A1, index.A2, RD, lo.RD, up.RD)
}
}
# XR.A1
for(i in 1:ncol(int.r$values.A1)) {
index.col <- length(int.r$A1nodes) + length(A2nodes) + 4 * (i - 1) + 1
for(j in 1:nrow(labels.A2)) {
index.A1 <- XR[,colnames(int.r$values.A1)[i]] == 1
if(ncol(labels.A2) == 1) {
index.A2 <- XR[,names(labels.A2)] == labels.A2[j,]
}
if(ncol(labels.A2) > 1) {
index.A2 <- apply(apply(XR[,names(labels.A2)[-ncol(labels.A2)]], 1, function(row) row == labels.A2[j,-ncol(labels.A2)]),2,prod) == 1
}
XR.est <- XR[index.A1 & index.A2, index.col]
lo.XR <- XR[index.A1 & index.A2, index.col + 2]
up.XR <- XR[index.A1 & index.A2, index.col + 3]
out.table[nrow(int.r$values.A1) + ncol(int.r$values.A1) + i, j] <- paste0(round(XR.est, digits = RR.OR.digits),
" [",
round(lo.XR, digits = RR.OR.digits),
",",
round(up.XR, digits = RR.OR.digits),
"]")
rm(index.A1, index.A2, XR.est, lo.XR, up.XR)
}
}
# XR.A2
for(i in 1:ncol(values.A2)) {
index.col <- length(int.r$A1nodes) + length(A2nodes) + 4 * length(int.r$A1nodes) + 4 * (i - 1) + 1
for(j in 1:nrow(labels.A1)) {
if(ncol(labels.A1) == 1) {
index.A1 <- XR[,names(labels.A1)] == labels.A1[j,]
}
if(ncol(labels.A1) > 1) {
index.A1 <- apply(apply(XR[,names(labels.A1)[-ncol(labels.A1)]], 1, function(row) row == labels.A1[j,-ncol(labels.A1)]),2,prod) == 1
}
index.A2 <- XR[,colnames(values.A2)[i]] == 1
XR.est <- XR[index.A1 & index.A2, index.col]
lo.XR <- XR[index.A1 & index.A2, index.col + 2]
up.XR <- XR[index.A1 & index.A2, index.col + 3]
out.table[j, nrow(values.A2) + ncol(values.A2) + i] <- paste0(round(XR.est, digits = RR.OR.digits),
" [",
round(lo.XR, digits = RR.OR.digits),
",",
round(up.XR, digits = RR.OR.digits),
"]")
rm(index.A1, index.A2, XR.est, lo.XR, up.XR)
}
}
# interaction
interaction.effects <- NULL
for(i in 1:ncol(int.r$values.A1)) {
for(j in 1:ncol(values.A2)) {
index.A1 <- int_res[,colnames(int.r$values.A1)[i]] == 1
index.A2 <- int_res[,colnames(values.A2)[j]] == 1
lab.A1 <- labels.A1[labels.A1[,i] == 1,ncol(labels.A1)]
lab.A2 <- labels.A2[labels.A2[,j] == 1,ncol(labels.A2)]
interaction.effects <- c(interaction.effects,
paste0(colnames(labels.A1)[ncol(labels.A1)],"=",lab.A1," vs.",ref.A1," & ",colnames(labels.A2)[ncol(labels.A2)],"=",lab.A2," vs.",ref.A2),
paste0(". additive Interaction = ",
round(int_res[index.A1 & index.A2,"a.INT"], digits = probab.digits),
" [",
round(int_res[index.A1 & index.A2,"lo.a.INT"], digits = probab.digits),
";",
round(int_res[index.A1 & index.A2,"up.a.INT"], digits = probab.digits),
"]"),
paste0(". RERI = ",
round(int_res[index.A1 & index.A2,"RERI"], digits = RR.OR.digits),
" [",
round(int_res[index.A1 & index.A2,"lo.RERI"], digits = RR.OR.digits),
";",
round(int_res[index.A1 & index.A2,"up.RERI"], digits = RR.OR.digits),
"]"),
paste0(". multiplicative Interaction = ",
round(int_res[index.A1 & index.A2,"m.INT"], digits = RR.OR.digits),
" [",
round(int_res[index.A1 & index.A2,"lo.m.INT"], digits = RR.OR.digits),
";",
round(int_res[index.A1 & index.A2,"up.m.INT"], digits = RR.OR.digits),
"]"))
}
}
if (int.r$transformOutcome == TRUE) {
ncol.without.RR <- nrow(labels.A2) + ncol(labels.A2[,-ncol(labels.A2)])
nrow.without.RR <- nrow(labels.A1) + ncol(labels.A1[,-ncol(labels.A1)])
out.table <- out.table[1:nrow.without.RR,1:ncol.without.RR]
}
return(list(out.table = out.table,
interaction.effects = interaction.effects))
}
set.seed(12345)
df <- generate.data.multcat(N = 1000, b = param.causal.model.multcat())
head(df)
df <- data.frame(df[,c("conf1","conf2","conf3")],
behav.2 = ifelse(df$behav == 2, 1, 0),
behav.3 = ifelse(df$behav == 3, 1, 0),
env.2 = ifelse(df$env == 2, 1, 0),
env.3 = ifelse(df$env == 3, 1, 0),
hlth.outcome = df$hlth.outcome)
head(df)
# Define Q and g formulas
# an A1 * A2 interaction term is recommended in the Q formula for the estimation
# of interaction effects
Q_formulas = c(hlth.outcome="Q.kplus1 ~ conf1 + conf2 + conf3 + behav.2 * env.2 + behav.2 * env.3 + behav.3 * env.2 + behav.3 * env.3")
g_formulas = c("behav.2 ~ conf1 + conf2",
"behav.3 ~ conf1 + conf2 + behav.2",
"env.2 ~ conf1 + conf3",
"env.3 ~ conf1 + conf3 + env.2")
# Define SuperLearner libraries
SL.library = list(Q=list("SL.glm"),
g=list("SL.glm"))
# Estimate MSM parameters by IPTW and TMLE
interaction.ltmle <- int.ltmleMSM(data = df,
Qform = Q_formulas,
gform = g_formulas,
A1nodes = c("behav.2","behav.3"),
A2nodes = c("env.2","env.3"),
Vnodes = NULL,
Lnodes = NULL,
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
interaction.ltmle$A1nodes
interaction.ltmle$A2nodes
interaction.ltmle$Vnodes
interaction.ltmle$Ynodes
interaction.ltmle$ltmle_MSM$beta
# (Intercept)       behav.2         env.2         env.3       behav.3 behav.2:env.2 behav.2:env.3 env.2:behav.3 env.3:behav.3
#  -2.4530092     1.9935141     0.6661055     1.3742659     2.8798853    -0.4855180    -0.4860343    -0.3558174     0.7099318
interaction.ltmle$ltmle_MSM$msm
interaction.ltmle$ltmle_MSM$beta.iptw
# (Intercept)       behav.2         env.2         env.3       behav.3 behav.2:env.2 behav.2:env.3 env.2:behav.3 env.3:behav.3
#  -2.4382946     1.9640679     0.6288329     1.3675612     2.8631821    -0.4000502    -0.4649394    -0.3368394     0.7288878
var(interaction.ltmle$ltmle_MSM$IC)
var(interaction.ltmle$ltmle_MSM$IC.iptw)
effects.3cat.tmle <- estim.int.effects(ltmle_MSM = interaction.ltmle,
estimator = "tmle")
effects.3cat.tmle$probs
effects.3cat.tmle$RD
effects.3cat.tmle$RR
effects.3cat.tmle$OR
effects.3cat.tmle$int
table_inter <- out.int.table(int.r = effects.3cat.tmle,
multipl = "RR",
labels.A1 = data.frame(effects.3cat.tmle$values.A1, behav = c(1,2,3)),
#   behav.2 behav.3 behav
# 1       0       0     1
# 2       1       0     2
# 3       0       1     3)
labels.A2 = data.frame(effects.3cat.tmle$values.A2, env = c(1,2,3)),
#   env.2 env.3 env
# 1     0     0   1
# 2     1     0   2
# 3     0     1   3
labels.V = NULL)
library(kableExtra)
kbl(table_inter$out.table,
caption = "Interaction effects estimated by TMLE") %>%
kable_classic() %>%
footnote(general = table_inter$interaction.effects)
int.r = effects.3cat.tmle
labels.A1 = data.frame(effects.3cat.tmle$values.A1, behav = c(1,2,3))
labels.A2 = data.frame(effects.3cat.tmle$values.A2, env = c(1,2,3))
labels.V = NULL
if(is.null(int.r$A2nodes)) {
A2nodes <- int.r$Vnodes
labels.A2 <- labels.V
values.A2 <- int.r$values.V
}
if(is.null(int.r$Vnodes)) {
A2nodes <- int.r$A2nodes
values.A2 <- int.r$values.A2
}
probs <- merge(int.r$probs, labels.A1, sort = FALSE)
probs <- merge(probs, labels.A2, sort = FALSE)
RD <- merge(int.r$RD, labels.A1, sort = FALSE)
RD <- merge(RD, labels.A2, sort = FALSE)
RR <- merge(int.r$RR, labels.A1, sort = FALSE)
RR <- merge(RR, labels.A2, sort = FALSE)
OR <- merge(int.r$OR, labels.A1, sort = FALSE)
OR <- merge(OR, labels.A2, sort = FALSE)
probs[,ncol(probs)] <- as.factor(probs[,ncol(probs)])
RD[,ncol(RD)] <- as.factor(RD[,ncol(RD)])
RR[,ncol(RR)] <- as.factor(RR[,ncol(RR)])
OR[,ncol(OR)] <- as.factor(OR[,ncol(OR)])
probs[,ncol(probs) - 1] <- as.factor(probs[,ncol(probs) - 1])
RD[,ncol(RD) - 1] <- as.factor(RD[,ncol(RD) - 1])
RR[,ncol(RR) - 1] <- as.factor(RR[,ncol(RR) - 1])
OR[,ncol(OR) - 1] <- as.factor(OR[,ncol(OR) - 1])
for(c in 1:ncol(RD)) {
RD[which(is.na(RD[,c])),c] <- 0
}
for(c in 1:ncol(RR)) {
RR[which(is.na(RR[,c])),c] <- 1
}
for(c in 1:ncol(OR)) {
OR[which(is.na(OR[,c])),c] <- 1
}
A1 <- A2 <- NULL
RD.A1 <- RD.A1.lo <- RD.A1.up <- RD.A2 <- RD.A2.lo <- RD.A2.up <- NULL
RR.A1 <- RR.A1.lo <- RR.A1.up <- RR.A2 <- RR.A2.lo <- RR.A2.up <- NULL
p <- p.lo <- p.up <- NULL
# The errorbars overlapped, so use position_dodge to move them horizontally
pd <- ggplot2::position_dodge(0.04) # move them .05 to the left and right
g1 <- ggplot2::ggplot(probs) +
ggplot2::aes(x = probs[,ncol(probs) - 1], color = probs[,ncol(probs)], y = p) + # A1, A2
ggplot2::geom_line(ggplot2::aes(group = probs[,ncol(probs)]), linetype = 2, position = pd) +
ggplot2::geom_errorbar(ggplot2::aes(group = probs[,ncol(probs)], ymin = p.lo, ymax = p.up),
width=.1, position = pd) +
ggplot2::geom_point(position = pd) +
ggplot2::xlab(names(probs)[ncol(probs) - 1]) +
ggplot2::ylab(int.r$Ynodes) +
ggplot2::labs(title = paste0("Effect of '",names(probs)[ncol(probs) - 1], "' in groups of '",names(probs)[ncol(probs)],"'")) +
ggplot2::guides(color = ggplot2::guide_legend(title = names(probs)[ncol(probs)]))
g1
probs
g2 <- ggplot2::ggplot(probs) +
ggplot2::aes(x = probs[,ncol(probs)], color = probs[,ncol(probs) - 1], y = p) + # A2, A1
ggplot2::geom_line(ggplot2::aes(group = probs[,ncol(probs) - 1]), linetype = 2, position = pd) + # A1
ggplot2::geom_errorbar(ggplot2::aes(group = probs[,ncol(probs) - 1], ymin = p.lo, ymax = p.up), # A1
width=.1, position = pd) +
ggplot2::geom_point(position = pd) +
ggplot2::xlab(names(probs)[ncol(probs)]) + # A2
ggplot2::ylab(int.r$Ynodes) +
ggplot2::labs(title = paste0("Effect of '",names(probs)[ncol(probs)], "' in groups of '",names(probs)[ncol(probs) - 1],"'")) + # A2, A1
ggplot2::guides(color = ggplot2::guide_legend(title = names(probs)[ncol(probs) - 1]))
g2
RD
