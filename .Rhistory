rm(list=ls())
param.causal.model <- function(p_L1 = 0.50, p_L2 = 0.20, p_L3 = 0.70,  # baseline confounders
b_A1 = 0.10, b_L1_A1 = 0.15, b_L2_A1 = 0.25,  # exposure A1
b_A2 = 0.15, b_L1_A2 = 0.20, b_L3_A2 = 0.20,  # exposure A2
Y_type = "binary", # or "continuous"
b_Y = 0.10,   # outcome Y
b_L1_Y = 0.02,
b_L2_Y = 0.02,
b_L3_Y = -0.02,
b_A1_Y = 0.3,
b_A2_Y = 0.1,
b_A1A2_Y = 0.4,
se_Y = NULL) {  # b_A1A2_Y is the interaction effect A1 * A2 -> Y
# check the sum of A1 parameters is not greater than 100%
try(if(b_A1 + b_L1_A1 + b_L1_A1 > 1)
stop("The sum of parameters to simulate A1 should not be greater than 100%"))
# check the sum of A2 parameters is not greater than 100%
try(if(b_A2 + b_L1_A2 + b_L3_A2 > 1)
stop("The sum of parameters to simulate A2 should not be greater than 100%"))
if (Y_type == "binary") {
# check the sum of Y parameters is not greater than 100% nor less than 0%
try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y > 1)
stop("The sum of parameters to simulate Y should not be greater than 100%"))
try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y < 0)
stop("The sum of parameters to simulate Y should not be less than 0%"))
try(if(!is.null(se_Y))
stop("se_Y should be NULL for binary outcomes Y"))
}
if (Y_type == "continuous") {
try(if(is.null(se_Y))
stop("se_Y should not be NULL for continuous outcomes Y"))
}
coef <- list(c(p_L1 = p_L1, p_L2 = p_L2, p_L3 = p_L3),
c(b_A1 = b_A1, b_L1_A1 = b_L1_A1, b_L2_A1 = b_L2_A1),
c(b_A2 = b_A2, b_L1_A2 = b_L1_A2, b_L3_A2 = b_L3_A2),
c(b_Y = b_Y, b_L1_Y = b_L1_Y, b_L2_Y = b_L2_Y, b_L3_Y = b_L3_Y,
b_A1_Y = b_A1_Y, b_A2_Y = b_A2_Y, b_A1A2_Y = b_A1A2_Y),
c(se_Y = se_Y))
return(coef)
}
generate.data <- function(N, b =  param.causal.model(), Y_type = "binary") {
conf1 <- rbinom(N, size = 1, prob = b[[1]]["p_L1"])
conf2 <- rbinom(N, size = 1, prob = b[[1]]["p_L2"])
conf3 <- rbinom(N, size = 1, prob = b[[1]]["p_L3"])
sex <- rbinom(N, size = 1, prob = b[[2]]["b_A1"] +
(b[[2]]["b_L1_A1"] * conf1) + (b[[2]]["b_L2_A1"] * conf2))
env <- rbinom(N, size = 1, prob = b[[3]]["b_A2"] +
(b[[3]]["b_L1_A2"] * conf1) + (b[[3]]["b_L3_A2"] * conf3))
if (Y_type == "binary") {
hlth.outcome <- rbinom(N, size = 1, prob = (b[[4]]["b_Y"] +
(b[[4]]["b_L1_Y"] * conf1) +
(b[[4]]["b_L2_Y"] * conf2) +
(b[[4]]["b_L3_Y"] * conf3) +
(b[[4]]["b_A1_Y"] * sex) +
(b[[4]]["b_A2_Y"] * env) +
(b[[4]]["b_A1A2_Y"] * sex * env)) )
}
if (Y_type == "continuous") {
hlth.outcome <- rnorm(N, mean = (b[[4]]["b_Y"] +
(b[[4]]["b_L1_Y"] * conf1) +
(b[[4]]["b_L2_Y"] * conf2) +
(b[[4]]["b_L3_Y"] * conf3) +
(b[[4]]["b_A1_Y"] * sex) +
(b[[4]]["b_A2_Y"] * env) +
(b[[4]]["b_A1A2_Y"] * sex * env)),
sd = b[[5]]["se_Y"])
}
data.sim <- data.frame(conf1, conf2, conf3, sex, env, hlth.outcome)
return(data.sim)
}
set.seed(54321)
df.cont.Y <- generate.data(N = 1000,
b = param.causal.model(Y_type = "continuous",
b_Y = 100, b_L1_Y = 10, b_L2_Y = 30,
b_L3_Y = -20, b_A1_Y = 10, b_A2_Y = 30,
b_A1A2_Y = 20, se_Y = 20),
Y_type = "continuous")
summary(df.cont.Y)
Q_formulas = c(hlth.outcome="Q.kplus1 ~ conf1 + conf2 + conf3 + sex * env")
g_formulas = c("sex ~ conf1 + conf2","env ~ conf1 + conf3")
# choose a set of fitting libraries to pass to SuperLearner:
SL.library = list(Q=list("SL.glm"),g=list("SL.glm"))
# apply the int.ltmleMSM function. In order to apply the TMLE and IPTW estimators,
# gcomp argument is set to FALSE.
continuous.interaction <- int.ltmleMSM(data = df.cont.Y,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
continuous.interaction
continuous.interaction$ltmle_MSM$transformOutcome
attr(continuous.interaction$ltmle_MSM$transformOutcome, "Yrange")
# The parameters of the MSM are estimated on the logit scale
continuous.interaction$ltmle_MSM$msm$family
# where the coefficients beta_0, beta_A1, beta_A2, and beta_A1_A2 are respectively
continuous.interaction$ltmle_MSM$msm$coefficients
rm(list=ls())
load_all()
param.causal.model <- function(p_L1 = 0.50, p_L2 = 0.20, p_L3 = 0.70,  # baseline confounders
b_A1 = 0.10, b_L1_A1 = 0.15, b_L2_A1 = 0.25,  # exposure A1
b_A2 = 0.15, b_L1_A2 = 0.20, b_L3_A2 = 0.20,  # exposure A2
Y_type = "binary", # or "continuous"
b_Y = 0.10,   # outcome Y
b_L1_Y = 0.02,
b_L2_Y = 0.02,
b_L3_Y = -0.02,
b_A1_Y = 0.3,
b_A2_Y = 0.1,
b_A1A2_Y = 0.4,
se_Y = NULL) {  # b_A1A2_Y is the interaction effect A1 * A2 -> Y
# check the sum of A1 parameters is not greater than 100%
try(if(b_A1 + b_L1_A1 + b_L1_A1 > 1)
stop("The sum of parameters to simulate A1 should not be greater than 100%"))
# check the sum of A2 parameters is not greater than 100%
try(if(b_A2 + b_L1_A2 + b_L3_A2 > 1)
stop("The sum of parameters to simulate A2 should not be greater than 100%"))
if (Y_type == "binary") {
# check the sum of Y parameters is not greater than 100% nor less than 0%
try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y > 1)
stop("The sum of parameters to simulate Y should not be greater than 100%"))
try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y < 0)
stop("The sum of parameters to simulate Y should not be less than 0%"))
try(if(!is.null(se_Y))
stop("se_Y should be NULL for binary outcomes Y"))
}
if (Y_type == "continuous") {
try(if(is.null(se_Y))
stop("se_Y should not be NULL for continuous outcomes Y"))
}
coef <- list(c(p_L1 = p_L1, p_L2 = p_L2, p_L3 = p_L3),
c(b_A1 = b_A1, b_L1_A1 = b_L1_A1, b_L2_A1 = b_L2_A1),
c(b_A2 = b_A2, b_L1_A2 = b_L1_A2, b_L3_A2 = b_L3_A2),
c(b_Y = b_Y, b_L1_Y = b_L1_Y, b_L2_Y = b_L2_Y, b_L3_Y = b_L3_Y,
b_A1_Y = b_A1_Y, b_A2_Y = b_A2_Y, b_A1A2_Y = b_A1A2_Y),
c(se_Y = se_Y))
return(coef)
}
generate.data <- function(N, b =  param.causal.model(), Y_type = "binary") {
conf1 <- rbinom(N, size = 1, prob = b[[1]]["p_L1"])
conf2 <- rbinom(N, size = 1, prob = b[[1]]["p_L2"])
conf3 <- rbinom(N, size = 1, prob = b[[1]]["p_L3"])
sex <- rbinom(N, size = 1, prob = b[[2]]["b_A1"] +
(b[[2]]["b_L1_A1"] * conf1) + (b[[2]]["b_L2_A1"] * conf2))
env <- rbinom(N, size = 1, prob = b[[3]]["b_A2"] +
(b[[3]]["b_L1_A2"] * conf1) + (b[[3]]["b_L3_A2"] * conf3))
if (Y_type == "binary") {
hlth.outcome <- rbinom(N, size = 1, prob = (b[[4]]["b_Y"] +
(b[[4]]["b_L1_Y"] * conf1) +
(b[[4]]["b_L2_Y"] * conf2) +
(b[[4]]["b_L3_Y"] * conf3) +
(b[[4]]["b_A1_Y"] * sex) +
(b[[4]]["b_A2_Y"] * env) +
(b[[4]]["b_A1A2_Y"] * sex * env)) )
}
if (Y_type == "continuous") {
hlth.outcome <- rnorm(N, mean = (b[[4]]["b_Y"] +
(b[[4]]["b_L1_Y"] * conf1) +
(b[[4]]["b_L2_Y"] * conf2) +
(b[[4]]["b_L3_Y"] * conf3) +
(b[[4]]["b_A1_Y"] * sex) +
(b[[4]]["b_A2_Y"] * env) +
(b[[4]]["b_A1A2_Y"] * sex * env)),
sd = b[[5]]["se_Y"])
}
data.sim <- data.frame(conf1, conf2, conf3, sex, env, hlth.outcome)
return(data.sim)
}
param.causal.model
rm(list=ls())
library(usethis)
library(devtools)
load_all(./R)
load_all("./R")
load_all("./R", TRUE)
library(devtools)
load_all()
load_all("./R")
param.causal.model()
df <- generate.data(N = 1000, b = param.causal.model())
rm(df)
param.causal.model <- function(p_L1 = 0.50, p_L2 = 0.20, p_L3 = 0.70,  # baseline confounders
b_A1 = 0.10, b_L1_A1 = 0.15, b_L2_A1 = 0.25,  # exposure A1
b_A2 = 0.15, b_L1_A2 = 0.20, b_L3_A2 = 0.20,  # exposure A2
Y_type = "binary", # or "continuous"
b_Y = 0.10,   # outcome Y
b_L1_Y = 0.02,
b_L2_Y = 0.02,
b_L3_Y = -0.02,
b_A1_Y = 0.3,
b_A2_Y = 0.1,
b_A1A2_Y = 0.4,
se_Y = NULL) {  # b_A1A2_Y is the interaction effect A1 * A2 -> Y
# check the sum of A1 parameters is not greater than 100%
try(if(b_A1 + b_L1_A1 + b_L1_A1 > 1)
stop("The sum of parameters to simulate A1 should not be greater than 100%"))
# check the sum of A2 parameters is not greater than 100%
try(if(b_A2 + b_L1_A2 + b_L3_A2 > 1)
stop("The sum of parameters to simulate A2 should not be greater than 100%"))
if (Y_type == "binary") {
# check the sum of Y parameters is not greater than 100% nor less than 0%
try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y > 1)
stop("The sum of parameters to simulate Y should not be greater than 100%"))
try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y < 0)
stop("The sum of parameters to simulate Y should not be less than 0%"))
try(if(!is.null(se_Y))
stop("se_Y should be NULL for binary outcomes Y"))
}
if (Y_type == "continuous") {
try(if(is.null(se_Y))
stop("se_Y should not be NULL for continuous outcomes Y"))
}
coef <- list(c(p_L1 = p_L1, p_L2 = p_L2, p_L3 = p_L3),
c(b_A1 = b_A1, b_L1_A1 = b_L1_A1, b_L2_A1 = b_L2_A1),
c(b_A2 = b_A2, b_L1_A2 = b_L1_A2, b_L3_A2 = b_L3_A2),
c(b_Y = b_Y, b_L1_Y = b_L1_Y, b_L2_Y = b_L2_Y, b_L3_Y = b_L3_Y,
b_A1_Y = b_A1_Y, b_A2_Y = b_A2_Y, b_A1A2_Y = b_A1A2_Y),
c(se_Y = se_Y))
return(coef)
}
generate.data <- function(N, b =  param.causal.model(), Y_type = "binary") {
conf1 <- rbinom(N, size = 1, prob = b[[1]]["p_L1"])
conf2 <- rbinom(N, size = 1, prob = b[[1]]["p_L2"])
conf3 <- rbinom(N, size = 1, prob = b[[1]]["p_L3"])
sex <- rbinom(N, size = 1, prob = b[[2]]["b_A1"] +
(b[[2]]["b_L1_A1"] * conf1) + (b[[2]]["b_L2_A1"] * conf2))
env <- rbinom(N, size = 1, prob = b[[3]]["b_A2"] +
(b[[3]]["b_L1_A2"] * conf1) + (b[[3]]["b_L3_A2"] * conf3))
if (Y_type == "binary") {
hlth.outcome <- rbinom(N, size = 1, prob = (b[[4]]["b_Y"] +
(b[[4]]["b_L1_Y"] * conf1) +
(b[[4]]["b_L2_Y"] * conf2) +
(b[[4]]["b_L3_Y"] * conf3) +
(b[[4]]["b_A1_Y"] * sex) +
(b[[4]]["b_A2_Y"] * env) +
(b[[4]]["b_A1A2_Y"] * sex * env)) )
}
if (Y_type == "continuous") {
hlth.outcome <- rnorm(N, mean = (b[[4]]["b_Y"] +
(b[[4]]["b_L1_Y"] * conf1) +
(b[[4]]["b_L2_Y"] * conf2) +
(b[[4]]["b_L3_Y"] * conf3) +
(b[[4]]["b_A1_Y"] * sex) +
(b[[4]]["b_A2_Y"] * env) +
(b[[4]]["b_A1A2_Y"] * sex * env)),
sd = b[[5]]["se_Y"])
}
data.sim <- data.frame(conf1, conf2, conf3, sex, env, hlth.outcome)
return(data.sim)
}
knit_with_parameters("~/Toulouse/Git repositories/MargIntTmle/README.Rmd")
unlink("README_cache", recursive = TRUE)
library(MargIntTmle)
library(devtools)
load_all
load_all()
rm(list = c("generate.data", "param.causal.model"))
load_all()
set.seed(12345)
df <- generate.data(N = 1000, b = param.causal.model())
head(df)
require(ltmle)
require(SuperLearner)
# define Q and g formulas following the argument notation of the ltmle package:
Q_formulas = c(hlth.outcome="Q.kplus1 ~ conf1 + conf2 + conf3 + sex * env")
g_formulas = c("sex ~ conf1 + conf2","env ~ conf1 + conf3")
# choose a set of fitting libraries to pass to SuperLearner:
SL.library = list(Q=list("SL.glm"),g=list("SL.glm"))
# apply the int.ltmleMSM function. In order to apply the TMLE and IPTW estimators,
# gcomp argument is set to FALSE.
interaction.ltmle <- int.ltmleMSM(data = df,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
# several quantities of interest for interaction effects are calculated using the
# estim.int.effects() function
est.tmle <- estim.int.effects(interaction.ltmle, estimator = "tmle")
table_inter <- out.int.table(int.r = est.tmle)
table_inter$out.table
table_inter$interaction.effects
library(kableExtra)
kbl(table_inter$out.table,
caption = "Interaction effects estimated by TMLE") %>%
kable_classic() %>%
footnote(general = table_inter$interaction.effects)
out.int.fig(est.tmle)
# require(MargIntTmle)
set.seed(54321)
beta <- param.causal.model(Y_type = "continuous", b_Y = 100, b_L1_Y = 10, b_L2_Y = 30,
b_L3_Y = -20, b_A1_Y = 10, b_A2_Y = 30, b_A1A2_Y = 20,
se_Y = 20)
df.cont.Y <- generate.data(N = 1000, b = beta, Y_type = "continuous")
summary(df.cont.Y)
generate.data <- function(N, b =  param.causal.model(), Y_type = "binary") {
conf1 <- rbinom(N, size = 1, prob = b[[1]]["p_L1"])
conf2 <- rbinom(N, size = 1, prob = b[[1]]["p_L2"])
conf3 <- rbinom(N, size = 1, prob = b[[1]]["p_L3"])
sex <- rbinom(N, size = 1, prob = b[[2]]["b_A1"] +
(b[[2]]["b_L1_A1"] * conf1) + (b[[2]]["b_L2_A1"] * conf2))
env <- rbinom(N, size = 1, prob = b[[3]]["b_A2"] +
(b[[3]]["b_L1_A2"] * conf1) + (b[[3]]["b_L3_A2"] * conf3))
if (Y_type == "binary") {
hlth.outcome <- rbinom(N, size = 1, prob = (b[[4]]["b_Y"] +
(b[[4]]["b_L1_Y"] * conf1) +
(b[[4]]["b_L2_Y"] * conf2) +
(b[[4]]["b_L3_Y"] * conf3) +
(b[[4]]["b_A1_Y"] * sex) +
(b[[4]]["b_A2_Y"] * env) +
(b[[4]]["b_A1A2_Y"] * sex * env)) )
}
if (Y_type == "continuous") {
hlth.outcome <- rnorm(N, mean = (b[[4]]["b_Y"] +
(b[[4]]["b_L1_Y"] * conf1) +
(b[[4]]["b_L2_Y"] * conf2) +
(b[[4]]["b_L3_Y"] * conf3) +
(b[[4]]["b_A1_Y"] * sex) +
(b[[4]]["b_A2_Y"] * env) +
(b[[4]]["b_A1A2_Y"] * sex * env)),
sd = b[[5]]["se_Y"])
}
data.sim <- data.frame(conf1, conf2, conf3, sex, env, hlth.outcome)
return(data.sim)
}
param.causal.model <- function(p_L1 = 0.50, p_L2 = 0.20, p_L3 = 0.70,  # baseline confounders
b_A1 = 0.10, b_L1_A1 = 0.15, b_L2_A1 = 0.25,  # exposure A1
b_A2 = 0.15, b_L1_A2 = 0.20, b_L3_A2 = 0.20,  # exposure A2
Y_type = "binary", # or "continuous"
b_Y = 0.10,   # outcome Y
b_L1_Y = 0.02,
b_L2_Y = 0.02,
b_L3_Y = -0.02,
b_A1_Y = 0.3,
b_A2_Y = 0.1,
b_A1A2_Y = 0.4,
se_Y = NULL) {  # b_A1A2_Y is the interaction effect A1 * A2 -> Y
# check the sum of A1 parameters is not greater than 100%
try(if(b_A1 + b_L1_A1 + b_L1_A1 > 1)
stop("The sum of parameters to simulate A1 should not be greater than 100%"))
# check the sum of A2 parameters is not greater than 100%
try(if(b_A2 + b_L1_A2 + b_L3_A2 > 1)
stop("The sum of parameters to simulate A2 should not be greater than 100%"))
if (Y_type == "binary") {
# check the sum of Y parameters is not greater than 100% nor less than 0%
try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y > 1)
stop("The sum of parameters to simulate Y should not be greater than 100%"))
try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y < 0)
stop("The sum of parameters to simulate Y should not be less than 0%"))
try(if(!is.null(se_Y))
stop("se_Y should be NULL for binary outcomes Y"))
}
if (Y_type == "continuous") {
try(if(is.null(se_Y))
stop("se_Y should not be NULL for continuous outcomes Y"))
}
coef <- list(c(p_L1 = p_L1, p_L2 = p_L2, p_L3 = p_L3),
c(b_A1 = b_A1, b_L1_A1 = b_L1_A1, b_L2_A1 = b_L2_A1),
c(b_A2 = b_A2, b_L1_A2 = b_L1_A2, b_L3_A2 = b_L3_A2),
c(b_Y = b_Y, b_L1_Y = b_L1_Y, b_L2_Y = b_L2_Y, b_L3_Y = b_L3_Y,
b_A1_Y = b_A1_Y, b_A2_Y = b_A2_Y, b_A1A2_Y = b_A1A2_Y),
c(se_Y = se_Y))
return(coef)
}
# require(MargIntTmle)
set.seed(12345)
df <- generate.data(N = 1000, b = param.causal.model())
head(df)
require(ltmle)
require(SuperLearner)
# define Q and g formulas following the argument notation of the ltmle package:
Q_formulas = c(hlth.outcome="Q.kplus1 ~ conf1 + conf2 + conf3 + sex * env")
g_formulas = c("sex ~ conf1 + conf2","env ~ conf1 + conf3")
# choose a set of fitting libraries to pass to SuperLearner:
SL.library = list(Q=list("SL.glm"),g=list("SL.glm"))
# apply the int.ltmleMSM function. In order to apply the TMLE and IPTW estimators,
# gcomp argument is set to FALSE.
interaction.ltmle <- int.ltmleMSM(data = df,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
# several quantities of interest for interaction effects are calculated using the
# estim.int.effects() function
est.tmle <- estim.int.effects(interaction.ltmle, estimator = "tmle")
table_inter <- out.int.table(int.r = est.tmle)
table_inter$out.table
table_inter$interaction.effects
library(kableExtra)
kbl(table_inter$out.table,
caption = "Interaction effects estimated by TMLE") %>%
kable_classic() %>%
footnote(general = table_inter$interaction.effects)
out.int.fig(est.tmle)
# require(MargIntTmle)
set.seed(54321)
beta <- param.causal.model(Y_type = "continuous", b_Y = 100, b_L1_Y = 10, b_L2_Y = 30,
b_L3_Y = -20, b_A1_Y = 10, b_A2_Y = 30, b_A1A2_Y = 20,
se_Y = 20)
df.cont.Y <- generate.data(N = 1000, b = beta, Y_type = "continuous")
summary(df.cont.Y)
library(devtools)
library(usethis)
load_all()
rm(list = c("generate.data", "param.causal.model"))
knit_with_parameters("~/Toulouse/Git repositories/MargIntTmle/README.Rmd")
library(MargIntTmle)
rm(list=ls())
load_all()
set.seed(54321)
beta <- param.causal.model(Y_type = "continuous", b_Y = 100, b_L1_Y = 10, b_L2_Y = 30,
b_L3_Y = -20, b_A1_Y = 10, b_A2_Y = 30, b_A1A2_Y = 20,
se_Y = 20)
df.cont.Y <- generate.data(N = 1000, b = beta, Y_type = "continuous")
summary(df.cont.Y)
Q_formulas = c(hlth.outcome="Q.kplus1 ~ conf1 + conf2 + conf3 + sex * env")
g_formulas = c("sex ~ conf1 + conf2","env ~ conf1 + conf3")
# choose a set of fitting libraries to pass to SuperLearner:
SL.library = list(Q=list("SL.glm"),g=list("SL.glm"))
# apply the int.ltmleMSM function. In order to apply the TMLE and IPTW estimators,
# gcomp argument is set to FALSE.
continuous.interaction <- int.ltmleMSM(data = df.cont.Y,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
continuous.interaction$ltmle_MSM$transformOutcome == TRUE
continuous.interaction$ltmle_MSM$transformOutcome == FALSE
load_all()
continuous.interaction$ltmle_MSM$transformOutcome
attr(continuous.interaction$ltmle_MSM$transformOutcome, "Yrange")
continuous.interaction$ltmle_MSM$msm$family
continuous.interaction$ltmle_MSM$msm$coefficients
est.tmle <- estim.int.effects(interaction.ltmle, estimator = "tmle")
est.tmle <- estim.int.effects(continuous.interaction, estimator = "tmle")
est.tmle
lm(data = df.cont.Y, hlth.outcome ~ conf1 + conf2 + conf3 + sex * env)
load_all()
est.tmle <- estim.int.effects(continuous.interaction, estimator = "tmle")
est.tmle
attr(continuous.interaction$ltmle_MSM$transformOutcome, "Yrange")
0.3748511 * (227.60003 - 15.41274) + 15.41274
0.4337114 * (227.60003 - 15.41274) + 15.41274
0.5253715 * (227.60003 - 15.41274) + 15.41274
0.6727495 * (227.60003 - 15.41274) + 15.41274
load_all()
continuous.interaction <- int.ltmleMSM(data = df.cont.Y,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
est.tmle <- estim.int.effects(continuous.interaction, estimator = "tmle")
est.tmle
est.tmle
continuous.interaction <- int.ltmleMSM(data = df.cont.Y,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
est.tmle <- estim.int.effects(continuous.interaction, estimator = "tmle")
est.tmle
load_all()
continuous.interaction <- int.ltmleMSM(data = df.cont.Y,
Qform = Q_formulas,
gform = g_formulas,
Anodes = c("sex", "env"),
Lnodes = c("conf1", "conf2", "conf3"),
Ynodes = c("hlth.outcome"),
SL.library = SL.library,
gcomp = FALSE,
iptw.only = FALSE,
survivalOutcome = FALSE,
variance.method = "ic")
attr(continuous.interaction$ltmle_MSM$transformOutcome, "Yrange")
est.tmle <- estim.int.effects(continuous.interaction, estimator = "tmle")
est.tmle
library(MargIntTmle)
library(devtools)
